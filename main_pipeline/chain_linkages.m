function carboxysome_data = chain_linkages(filename, carboxysome_data, min_distance, max_distance, max_angle, factor)
% This function determines which chains combine to form a lattice based on
% their distance apart and the angle between them. Pairs of chains that are
% found to form a lattice are saved in a property of the carboxysome they
% belong to called "chain_links".
%
% Inputs
% filename - the name of the file the data originates from. If the only
%            input is filename then it will run every script in the main 
%            pipeline up to here automatically
% carboxysome_data - an array of Carboxysome objects filled with rubisco
%                    data
% min_distance - the minimum allowable distance in nm between linked
%                chains
% max_distance - the maximum allowable distance in nm between linked
%                chains
% max_angle - the maximum allowable angle in degrees between linked chains
%
% Outputs
% carboxysome_data - an array of Carboxysome objects with the chain_links
%                    property appropriately populated
%
% chain_linkages.m Â© 2025 is licensed under CC BY-NC-SA 4.0
    
    % Allow the user to run this script as a starting point, will call
    % the previous scripts in the pipeline and obtain the necessary data
    if nargin == 1
        carboxysome_data = chain_maker(filename);
    end
    
    %% important constants
    % load constants from external file. change depending on dataset
    CONSTANTS = constants();
    rubisco_diameter = CONSTANTS.RUBISCO_DIAMETER_M / CONSTANTS.PIXEL_SIZE;
    
    % auto fills the minimum distance and maximum distances and angles based on
    % analysis of the histogram generated by lattice_spacing_analysis.m
    if nargin < 3
        min_distance = 10; % in nanometers
        max_distance = 14; % in nanometers
        max_angle = 22; % in degrees
        factor = 0.3; % the minimum fraction of the chains that must be side by side to be linked
    end
    pixelSize = CONSTANTS.PIXEL_SIZE;
    
    max_distance = max_distance*(10^-9)/pixelSize; % max distance between two linked chains in pixels
    min_distance = min_distance*(10^-9)/pixelSize; % min distance between two linked chains in pixels
    
    % to display all counts of connections between a chain and its neighbors
    g = [];

    for carb = carboxysome_data % for each carboxysome
        chain_count = length(carb.chains);
        lattices = Chain_Pair.empty; % prepare an array of chain pair objects
        lattices(length(chain_count)*length(chain_count)) = Chain_Pair();
        last_index = 0;
        % goes through every chain
        for i = 1:chain_count
            iChain = carb.chains(i);
            c = 1; % c counts how many linkages iChain makes
            
            % and compares it to every other chain
            for j = 1:chain_count
                if any([lattices.I_index] == j & [lattices.J_index] == i) % if this linkage alredy exists
                    c = c+1; % increment c without making a new chain pair object
                elseif i < j % if this pair has not been checked yet and the chains are different
                    jChain = carb.chains(j);
        
                    % uses the closest points between the chains to quantify
                    % the distance between them
                    [distance, angle] = chain_distance_closest(iChain, jChain, carb, rubisco_diameter, factor);
        
                    % if chains meet distance and angle parameters
                    if distance < max_distance && distance > min_distance && angle < max_angle
                        % make chain pair out of them
                        lattices(last_index + 1) =  Chain_Pair(carb.carb_index, i, j, iChain.tag, jChain.tag, angle, distance, carb.concentration);
                        c = c+1;
                        last_index = last_index + 1;
                    end
                end
            end

            % If chain is surrounded by at least 6 others it is a central
            % chain. The value of c is always one more than the number of
            % chain linkages, so if c >= 7, then # of linkages >= 6.
            if c >= 7
                for rubisco_index = iChain.indices
                    % set in_central_chain property to true for each
                    % rubisco in this chain
                    carb.rubisco([carb.rubisco.index] == rubisco_index).in_central_chain = true;
                end
            end

            % update the chain linkage counter
            while length(g) < c
                g(end+1)= 0;
            end
            g(c) = g(c)+1;
        end
        if last_index == 0
            lattices = [];
        else
           
            lattices = lattices(1:last_index);
        end
        carb.chain_links = lattices; % store the chain pairs in the carboxysome object
    end

    % print the possible numbers of linkages a chain can have
    fprintf('# of Linkages: ');
    for i = 1:length(g)
        fprintf('%-5i ', i-1);
    end

    % print the number of times a chain had that many linkages
    fprintf('\n       Counts: ');
    for i = 1:length(g)
        fprintf('%-5i ', g(i));
    end
    fprintf('\n');
end

    %% Helper Functions

function [shortest_distance, angle] = chain_distance_closest(chain_i, chain_j, carb, rubisco_diameter, factor)
% Determine the distance between two chains. Each chain is broken up into 
% straight segments which connect adjacent rubisco. The shortest distance 
% between two segments is calculated for every combination of one segment 
% from chain i and one segment from chain j. The minimum of all these 
% segment-to-segment distances is returned as the distance between the 
% chains.
% 
% Inputs
% chain_i and chain_j are Rubisco_Chain objects whose distance is
% calculated. carb is a Carboxysome object which contains chains i and j.
% rubisco_diameter is a number which represents the diameter of a rubisco
% in pixels.
%
% Outputs
% This function returns distance, the distance between the two chains, and 
% angle, the angle between the two chains.

    % Fetch the lists of rubisco that are in these chains
    rubiscos_i = chain_i.tags;
    rubiscos_j = chain_j.tags;

    % Fetch the xyz positions of the rubiscos in each chain
    rubiscos_i_positions = get_rubisco_positions(rubiscos_i, carb);
    rubiscos_j_positions = get_rubisco_positions(rubiscos_j, carb);
    
    % Create arrays to store segments. Each row represents one
    % segment. Each segment has a xyz point in space (columns 1-3), three
    % vector components describing its direction (columns 5-7), and a
    % parameter lambda (column 4) which is used to calculate the distance
    % between the two endpoints of the segment.
    chain_i_segments = generate_segments(rubiscos_i_positions, carb, rubiscos_i, rubisco_diameter);
    chain_j_segments = generate_segments(rubiscos_j_positions, carb, rubiscos_j, rubisco_diameter);

    % Initialize a variable to store the minimum distance between the
    % chains.
    shortest_distance = inf;

    % Loop through the segments in chain i and calculate each one's minimum
    % distance to each segment in chain j
    for k = 1:size(chain_i_segments, 1)    
        segment_i = chain_i_segments(k, :);

        % Calculate where the endpoints of segment i are.
        i_endpoints = [segment_i(1:3); segment_i(1:3) + segment_i(4) * segment_i(5:7)];

        % For each segment in chain j
        for l = 1:size(chain_j_segments, 1)
            segment_distance = inf; % the least distance between these two segments
            segment_j = chain_j_segments(l, :);

            % Calculate where the endpoints of segment j are
            j_endpoints = [segment_j(1:3); segment_j(1:3) + segment_j(4) * segment_j(5:7)];

            % Calculate dot products used to find the location of the
            % minimum distance between the chains
            db = dot(segment_j(5:7), segment_i(5:7));
            bca = dot(segment_i(5:7), segment_j(1:3)-segment_i(1:3));
            bb = dot(segment_i(5:7), segment_i(5:7));
            dca = dot(segment_j(5:7), segment_j(1:3)-segment_i(1:3));
            dd = dot(segment_j(5:7), segment_j(5:7));

            % These equations represent the solutions to a minimization
            % problem. They were derived by setting the partial derivatives
            % of the distance between two points on opposite lines equal to
            % zero. s and t are scalars used to find how far along the line
            % segments the points that minimize distance are.
            s = (db * bca - bb * dca) / (bb * dd - db * db); % for segment j
            t = (dca + dd * s) / db; % for segment i

            % if the points that minimize distance both lay on the segments
            if s >= 0 && t >= 0 && s <= segment_j(4) && t <= segment_i(4)
                % find the points that minimize distance
                point_on_j = segment_j(1:3) + s * segment_j(5:7);
                point_on_i = segment_i(1:3) + t * segment_i(5:7);

                % calculate the distance between them
                segment_distance = sqrt(sum((point_on_i - point_on_j) .^ 2));
            end

            % find the shortest distance between segment i's first endpoint
            % and segment j
            [j_point_1, ~] = closest_point_on_segment_to_point(i_endpoints(1, :), j_endpoints);
            endpoints_1_dist = sqrt(sum((i_endpoints(1, :) - j_point_1) .^ 2));

            % find the shortest distance between segment i's second 
            % endpoint and segment j
            [j_point_2, ~] = closest_point_on_segment_to_point(i_endpoints(2, :), j_endpoints);
            endpoints_2_dist = sqrt(sum((i_endpoints(2, :) - j_point_2) .^ 2));

            % find the shortest distance between segment j's first endpoint
            % and segment i
            [i_point_1, ~] = closest_point_on_segment_to_point(j_endpoints(1, :), i_endpoints);
            endpoints_3_dist = sqrt(sum((j_endpoints(1, :) - i_point_1) .^ 2));

            % find the shortest distance between segment j's second 
            % endpoint and segment i
            [i_point_2, ~] = closest_point_on_segment_to_point(j_endpoints(2, :), i_endpoints);
            endpoints_4_dist = sqrt(sum((j_endpoints(2, :) - i_point_2) .^ 2));

            % of all 4 or 5 distances calculated, keep the minimum
            segment_distance = min([segment_distance, endpoints_1_dist, endpoints_2_dist, endpoints_3_dist, endpoints_4_dist]);
            
            % if the distance between these segments is the new shortest,
            % keep it
            if segment_distance < shortest_distance
                shortest_distance = segment_distance;
            end
        end
    end

    % finds how far their overlap factor is
    overlap = find_overlap(chain_i_segments, chain_j_segments);

    % if chains aren't side by side (for example if only two chain ends
    % happen to be close), set its distance to zero so it won't be
    % considered for a linkage
    if overlap < factor
        shortest_distance = 0;
    end

    % Calculate the angle between the two chains
    angle = acos(dot(chain_i.average_vector, chain_j.average_vector)/(norm(chain_i.average_vector) * norm(chain_j.average_vector)))*180/pi;

    if angle > 90
        angle = 180 - angle;
    end
end

function rubisco_positions = get_rubisco_positions(rubisco_tags, carbox)
% Fetches the xyz positions of each rubisco in a chain and stores them.
% Each row represents one rubisco.
    rubisco_positions = zeros(length(rubisco_tags), 3); % array to hold positions

    for rubisco_tag = rubisco_tags % for each rubisco in the chain
        x_position = carbox.rubisco(find([carbox.rubisco.tag]==rubisco_tag)).x; % find its x position
        y_position = carbox.rubisco(find([carbox.rubisco.tag]==rubisco_tag)).y; % find its y position
        z_position = carbox.rubisco(find([carbox.rubisco.tag]==rubisco_tag)).z; % find its z position
        rubisco_positions(rubisco_tags == rubisco_tag, :) = [x_position y_position z_position]; % store them in array
    end
end

function chain_segments = generate_segments(rubisco_positions, carbox, rubisco_tags, rubisco_diameter)
% Creates the segments that make up a chain. For a chain with N rubisco
% there are N+1 segments. We make N-1 interior segments between rubisco and
% two exterior segments which extend from an end-of-chain rubisco center to
% its edge.

% Calculate interior segments between adjacent rubisco (not end-of-chain 
% extensions yet).
    chain_segments = zeros(size(rubisco_positions, 1) + 1, 7); % an array to hold chain segments
    
    for k = 2:length(rubisco_tags) % for each interior segment
        line_segment = rubisco_positions(k, :) - rubisco_positions(k - 1, :);
        chain_segments(k, 1:3) = rubisco_positions(k - 1, :); % segment start point
        chain_segments(k, 4) = 1; % lambda of segment
        chain_segments(k, 5:7) = line_segment; % direction of segment
    end

    % Determine the direction vectors of the end-of-chain extensions based
    % on the orientation vectors of the end-of-chain rubisco. The rubisco
    % orientations are in one of two possible directions. To get the one 
    % that extends the chain we check the dot product of the orientation 
    % vector with the next adjacent segment.

    % For the first rubisco in the chain, the vectors should point opposite
    % directions. If their dot product is positive we flip the rubisco
    % orientation vector and use that as the direction of the end-of-chain
    % extension. Else we take the orientation vector as is.
    if dot(carbox.rubisco(find([carbox.rubisco.tag]==rubisco_tags(1))).vector, chain_segments(2, 5:7)) > 0
        chain_segments(1, 5:7) = -1 * carbox.rubisco(find([carbox.rubisco.tag]==rubisco_tags(1))).vector;
    else
        chain_segments(1, 5:7) = carbox.rubisco(find([carbox.rubisco.tag]==rubisco_tags(1))).vector;
    end
    
    % For the last rubisco in the chain, the vectors should point in the 
    % same direction. If their dot product is negative we flip the rubisco
    % orientation vector and use that as the direction of the end-of-chain
    % extension. Else we take the orientation vector as is.
    if dot(carbox.rubisco(find([carbox.rubisco.tag]==rubisco_tags(end))).vector, chain_segments(end - 1, 5:7)) < 0
        chain_segments(end, 5:7) = -1 * carbox.rubisco(find([carbox.rubisco.tag]==rubisco_tags(end))).vector;
    else
        chain_segments(end, 5:7) = carbox.rubisco(find([carbox.rubisco.tag]==rubisco_tags(end))).vector;
    end
    
    % Set the end-of-chain segment xyz as the xyz of the end-of-chain 
    % rubisco and set their extension lengths to half of the diameter of a 
    % rubisco.
    chain_segments(1, 1:4) = [rubisco_positions(1, :) rubisco_diameter/2];
    chain_segments(end, 1:4) = [rubisco_positions(end, :) rubisco_diameter/2];
end

function [closest_point, t] = closest_point_on_segment_to_point(free_point, endpoints)
% Calculates the spot on a line segment which minimizes the distance to a
% free point. This is done by calculating t, the ratio of the scalar
% projection (dot product) of the point on the segment divided by the
% length of the segment.

    segment = endpoints(2, :) - endpoints(1, :); % a vector representing the segment
    segment_to_point = free_point - endpoints(1, :); % a vector from one segment endpoint to the free point

    t = dot(segment, segment_to_point) / dot(segment, segment); % how far along the segment the closest point is

    % for t<0 and t>1 the closest point is out of the bounds of the
    % segment. In this case we take the nearest endpoint (represented when
    % t=0 or t=1) as the closest point.
    if t < 0
        t = 0;
    elseif t > 1
        t = 1;
    end

    % Calculates the xyz coordinates of the closest point
    closest_point = endpoints(1, :) + t * segment;
end

function overlap = find_overlap(i_chain_segments, j_chain_segments)
    % finds the overlap between the chains by finding how far each endpoint
    % of one chain extends along the other chain. The maximum overlap value
    % calculated is used
    [i_chain_ends, j_chain_ends] = findEnds(i_chain_segments, j_chain_segments);

    % length of projection along the opposite chain axis from the endpoints

    % i endpoints' projections to the other chain
    [~, t_i1] = closest_point_on_segment_to_point(i_chain_ends(1, :), j_chain_ends);
    [~, t_i2] = closest_point_on_segment_to_point(i_chain_ends(2, :), j_chain_ends);

    % j endpoints' projections to the other chain
    [~, t_j1] = closest_point_on_segment_to_point(j_chain_ends(1, :), i_chain_ends);
    [~, t_j2] = closest_point_on_segment_to_point(j_chain_ends(2, :), i_chain_ends);

    overlap_i = abs(t_i1 - t_i2);
    overlap_j = abs(t_j1 - t_j2);

    % if one chain is entirely contained in the shadow of the other,
    % that is counted as proper overlap. therefore the maximum is taken
    overlap = max([overlap_i, overlap_j]);
end

function [i_ends, j_ends] = findEnds(i_segments, j_segments)
% finds the locations of the chain endpoints
    i_end_1 = i_segments(1,1:3) + i_segments(1, 5:7) * i_segments(1,4);
    i_end_2 = i_segments(end,1:3) + i_segments(end, 5:7) * i_segments(end,4);
    j_end_1 = j_segments(1,1:3) + j_segments(1, 5:7) * j_segments(1,4);
    j_end_2 = j_segments(end,1:3) + j_segments(end, 5:7) * j_segments(end,4);

    i_ends = [i_end_1; i_end_2];
    j_ends = [j_end_1; j_end_2];
end